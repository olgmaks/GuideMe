package com.epam.gm.olgmaks.absractdao.crudoperation;

import com.epam.gm.olgmaks.absractdao.annotation.AutoGenerated;
import com.epam.gm.olgmaks.absractdao.annotation.Column;
import com.epam.gm.olgmaks.absractdao.general.AbstractDao;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Created by OLEG on 07.06.2015.
 */
public class UpdateHelper<T> extends AbstractHelper<T> {

    private String whereCondition;
    private String namesAndValuesForUpdating;
    private List<String> conditionFields;

    public UpdateHelper(Connection connection, Class<T> clazz) {
        super(connection, clazz);
        whereCondition = new String();
        namesAndValuesForUpdating = new String();
        conditionFields = new ArrayList<>();

    }

    public void init(T t) throws IllegalAccessException {
        System.out.println("init method");

        for (Field f : fields) {
            f.setAccessible(true);
            if (!f.isAnnotationPresent(AutoGenerated.class)) {
                if (f.getAnnotation(Column.class) != null) {
                    String fieldName = f.getAnnotation(Column.class).value();
                    Object fieldValue = f.get(t);
                    System.out.println(fieldName + fieldValue);
                    fieldNames.add(fieldName);
                    fieldValues.add(fieldValue);
                    unknownValues += "?,";
                    fieldNameSequence += fieldName + ",";
                }
            }
        }

        fieldNames.removeAll(conditionFields);

        for (String fieldName : fieldNames) {
            String definitionAppend = "=?,";
            namesAndValuesForUpdating += fieldName + definitionAppend;
        }

        for (String conditionField : conditionFields) {
            whereCondition += conditionField + "=? AND, ";
        }

        namesAndValuesForUpdating = namesAndValuesForUpdating.substring(0, namesAndValuesForUpdating.length() - 1);
        whereCondition = whereCondition.substring(0, whereCondition.length() - 5);
        System.out.println("table name : " + tableName);
        System.out.println("names and values : " + namesAndValuesForUpdating);
        System.out.println("update conditions : " + whereCondition);
    }

    public PreparedStatement update(T t, String[] updateConditions) throws SQLException, IllegalAccessException {
        System.out.println("update method");
        for (String condition : updateConditions) {
            conditionFields.add(condition);
        }
        init(t);
        String sql = String.format(AbstractDao.UPDATE, tableName, namesAndValuesForUpdating, whereCondition);
        System.out.println(sql);
        PreparedStatement statement = connection.prepareStatement(sql);
        int index = 1;
        // Setting values to set
        for (String fieldName : fieldNames) {
            for (Field field : fields) {
                if (fieldName != null && field.getAnnotation(Column.class).value().equals(fieldName)) {
                    statement.setObject(index++, field.get(t));
                }
            }
        }
        //Setting updating conditions
        for (String conditionField : conditionFields) {
            for (Field field : fields) {
                if (conditionField != null && field.getAnnotation(Column.class).value().equals(conditionField)) {
                    statement.setObject(index++, field.get(t));
                }
            }
        }
        return statement;
    }

    public PreparedStatement update(Integer id, Map<String, Object> updates) throws SQLException {
        String updatesInString = new String();
        String whereConditionInString = new String();
        Iterator<String> keys = updates.keySet().iterator();
        while (keys.hasNext()) {
            updatesInString += keys.next() + "=" + "?,";
        }
        updatesInString = updatesInString.substring(0, updatesInString.length() - 1);
        whereConditionInString = "id = ?";

        String sql = String.format(AbstractDao.UPDATE, tableName, updatesInString, whereConditionInString);
        System.out.println(sql);
        PreparedStatement statement = connection.prepareStatement(sql);
        int index = 1;
        for (String key : updates.keySet()) {
            statement.setObject(index++, updates.get(key));
        }
        statement.setInt(index++, id);
        return statement;
    }


    public PreparedStatement update(Map<String, Object> updates, String joined, String where) throws SQLException {

        String sql = "UPDATE" + " " + tableName + " " + joined;

        String updatesInString = new String();

        Iterator<String> keys = updates.keySet().iterator();
        while (keys.hasNext()) {
            updatesInString += tableName + "." + keys.next() + "=" + "?,";
        }
        updatesInString = updatesInString.substring(0, updatesInString.length() - 1);

        sql += " " + "SET" + " " + updatesInString + " " + where;

        System.out.println(sql);

        PreparedStatement statement = connection.prepareStatement(sql);

        int index = 1;
        for (String key : updates.keySet()) {
            statement.setObject(index++, updates.get(key));
        }

        return statement;
    }


}
